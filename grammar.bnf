// Pdef grammar in BNF with JetBrains GrammarKit support.
{
    tokens=[
        // Punctuation
        dot='.'
        colon=':'
        comma=','
        semi=';'
        less='<'
        greater='>'
        lbrace='{'
        rbrace='}'
        lparent='('
        rparent=')'

        // Module and imports
        module='module'
        from='from'
        import='import'

        // Native types
        bool='bool'
        int16='int16'
        int32='int32'
        int64='int64'
        float='float'
        double='double'
        string='string'
        void='void'
        list='list'
        set='set'
        map='map'

        // Definition types
        message_token='message'
        interface_token='interface'
        exception_token='exception'
        enum_token='enum'

        // Attributes
        discriminator='@discriminator'
        post='@post'
        query='@query'
        throws='@throws'

        // Idd, docs and comments.
        // Dots cannot be used in definition, method, enum value, and field names.
        id='regexp:[a-zA-Z]{1}[a-zA-Z0-9_]*'
        doc='regexp:/\*\*(.|\n|\r)*?\*/'
        comment='regexp://.*'
    ]
}
// Single quotes (') are used to enclose tokens in GrammarKit when they clash with the rules,
// i.e. a message rule and a message_token 'message'.

File            ::= doc? 'module' TypeName ';' ImportBlock* Definition*
TypeName        ::= id ('.' id)*
ModuleName      ::= id ('.' id)*

ImportBlock     ::= AbsoluteImport | RelativeImport
AbsoluteImport  ::= import ModuleName ';'
RelativeImport  ::= from ModuleName import ModuleName (',' ModuleName)* ';'

Definition      ::= doc? (Enum | Message | Interface)

Enum            ::= 'enum' id '{' EnumValues? '}'
EnumValues      ::= id (',' id)* ';'?

Message         ::= ('message' | 'exception') id (':' MessageBase)? '{' Field* '}'
MessageBase     ::= Type ('(' Type ')')?  // Base with an optional polymorphic type.

Field           ::= id Type FieldDiscriminator? ';'
FieldDiscriminator ::= '@discriminator'

Interface       ::= InterfaceExc? 'interface' id '{' Method* '}'
InterfaceExc    ::= '@throws' '(' TypeName ')'

Method          ::= doc? MethodPost? id '(' Args? ')' Type ';'
MethodPost      ::= '@post'
Arg             ::= doc? id Type ('@post' | '@query')?
Args            ::= Arg (',' Arg)*

Type            ::= ValueType | ListType | SetType | MapType | TypeName
ValueType       ::= bool
                    | int16
                    | int32
                    | int64
                    | float
                    | double
                    | string
                    | void
ListType        ::= list '<' Type '>'
SetType         ::= set '<' Type '>'
MapType         ::= map '<' Type ',' Type '>'
