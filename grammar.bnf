// Pdef grammar in BNF with JetBrains GrammarKit support.
{
    tokens=[
        // Punctuation
        colon=':'
        comma=','
        semi=';'
        less='<'
        greater='>'
        lbrace='{'
        rbrace='}'
        lparent='('
        rparent=')'

        // Module and imports
        module='module'
        from='from'
        import='import'

        // Native types
        bool='bool'
        int16='int16'
        int32='int32'
        int64='int64'
        float='float'
        double='double'
        string='string'
        object='object'
        void='void'
        list='list'
        set='set'
        map='map'

        // Definition types
        message_token='message'
        interface_token='interface'
        exception_token='exception'
        enum_token='enum'

        throws='throws'

        // Options
        discriminator='@discriminator'
        form='@form'
        index='@index'
        post='@post'

        // Idd, docs and comments.
        // Dots cannot be used in definition, method, enum value, and field names.
        id='regexp:[a-zA-Z]{1}[a-zA-Z0-9_]*(\.[a-zA-Z]{1}[a-zA-Z0-9_]*)*'
        doc='regexp:/\*\*(.|\n|\r)*?\*/'
        comment='regexp://.*'
    ]
}
// Single quotes (') are used to enclose tokens in GrammarKit when they clash with the rules,
// i.e. the message rule and the message_token 'message'.

File          ::= doc? module id ';' ImportBlock* Definition*

ImportBlock     ::= AbsoluteImport | RelativeImport
AbsoluteImport  ::= import id ';'
RelativeImport  ::= from id import id (',' id)* ';'

Definition    ::= doc? (Enum | Message | Interface)

Enum          ::= 'enum' id '{' EnumValues '}'
EnumValues    ::= EnumValue (',' EnumValue)* ';'?
EnumValue     ::= doc? id

Message       ::= MessageOption* ('message' | 'exception') id (':' MessageBase)? '{' Field* '}'
MessageBase   ::= id ('(' id ')')?  // Base with an optional polymorphic type.
MessageOption ::= '@form'

Field         ::= doc? id Type FieldOption* ';'
FieldOption   ::= '@discriminator'

Interface     ::= 'interface' id (':' InterfaceBase? InterfaceExc?)? '{' Method* '}'
InterfaceBase ::= id
InterfaceExc  ::= throws id

Method        ::= doc? MethodOption* id '(' MethodArgs? ')' Type ';'
MethodArg     ::= doc? id Type
MethodArgs    ::= MethodArg (',' MethodArg)*
MethodOption  ::= '@index' | '@post'

Type          ::= ValueType | ListType | SetType | MapType | id
ValueType     ::= bool
                | int16
                | int32
                | int64
                | float
                | double
                | string
                | object
                | void
ListType      ::= list '<' Type '>'
SetType       ::= set '<' Type '>'
MapType       ::= map '<' Type ',' Type '>'
